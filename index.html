<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>MIDI Tightness Stats</title>

  <style>
    body {
      background: #0b0b0b;
      color: #e0e0e0;
      font-family: monospace;
      margin: 10px;
    }

    select {
      background: #111;
      color: #eee;
      border: 1px solid #333;
      font-size: 13px;
      margin-bottom: 6px;
    }

    #top {
      font-size: 22px;
      margin-bottom: 4px;
    }

    #stats {
      font-size: 14px;
      opacity: 0.85;
    }

    #controls {
      font-size: 12px;
      margin-bottom: 6px;
    }

    #grid {
      display: grid;
      grid-template-columns: repeat(5, auto);
      gap: 10px;
      font-size: 12px;
      line-height: 1.35;
    }

    .octave {
      white-space: pre;
    }

    label {
      cursor: pointer;
    }

    #leaderboard {
      margin-top: 12px;
      font-size: 16px;
      color: #ffd700;
    }

    #hist {
      margin-top: 10px;
      border: 1px solid #222;
    }
  </style>
</head>

<body>

  <select id="midiSelect"></select>

  <div id="controls">
    <label>
      <input type="checkbox" id="accToggle" checked>
      show accidentals
    </label>
  </div>

  <div id="leaderboard">
    Top notes: <span id="topNotes"></span>
  </div>

  <div id="top">
    TOTAL: <span id="total">0</span>
    <span id="stats">
      | recent: <span id="nps">0.00</span> n/s
      | avg vel: <span id="avgVel">0</span>
      | tempo: <span id="bpm">—</span> bpm
    </span>
  </div>

  <div id="grid"></div>

  <canvas id="hist" width="1400" height="120"></canvas>
  <canvas id="target" width="1400" height="120" style="border:1px solid #222; margin-top:5px;"></canvas>

  <div>
    blue
    # <span id="count_left"></span>
    bary <span id="bary_left"></span>ms
  </div>
  <div>
    rose
    # <span id="count_right"></span>
    bary <span id="bary_right"></span>ms
  </div>
  <div>
    tempo <span id="tempo_right"></span>bpm
  </div>
  <div>
    σ (rose) <span id="std_right"></span>ms
  </div>
  <div>
    σ (blue) <span id="std_left"></span>ms
  </div>

  <script>


    /* ---------------- CONFIG ---------------- */
    const OCTAVES = [2, 3, 4, 5, 6];
    const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

    const WINDOW_SEC = 5;
    const VEL_WINDOW = 16;
    const MAX_INTERVAL_MS = 20000;

    const BAR_NOTES = 18;
    const NOTE_LETTERS = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];

    const HIST_MAX_MS = 500;
    const HIST_BINS = 60;

    const NOTE_BUFFER = 72;

    /* ---------------- STATE ---------------- */
    let counters = {};
    let lastTimes = {};
    let intervals = {};

    let total = 0;
    let noteTimes = [];
    let velocities = [];

    let barTimes = [];
    let bpm = 0;

    let deltas = [];
    // let lastVelocities = [];

    let currentInput = null;
    let showAccidentals = true;

    let count_left = 0, count_right = 0;
    let bary_left = 0, bary_right = 0;
    let std_left_ms = 0, std_right_ms = 0;


    /* ---------------- INIT ---------------- */
    for (let o of OCTAVES) {
      for (let i = 0; i < 12; i++) {
        const midi = (o + 1) * 12 + i;
        counters[midi] = 0;
        lastTimes[midi] = null;
        intervals[midi] = null;
      }
    }

    function isAccidental(i) {
      return NOTES[i].includes('#');
    }

    /* ---------------- LEADERBOARD ---------------- */
    function renderLeaderboard() {
      let totals = {};
      for (let l of NOTE_LETTERS) totals[l] = 0;

      for (let midi in counters) {
        const note = NOTES[midi % 12].replace('#', '');
        if (totals[note] !== undefined) {
          totals[note] += counters[midi];
        }
      }

      const sorted = Object.entries(totals)
        .sort((a, b) => b[1] - a[1]);

      document.getElementById('topNotes').textContent =
        sorted.map(([l, c]) => `${l}:${c}`).join(' ');
    }

    /* ---------------- HISTOGRAM ---------------- */
    function renderHistogram() {
      const c = document.getElementById('hist');
      const ctx = c.getContext('2d');

      ctx.clearRect(0, 0, c.width, c.height);

      let bins = new Array(HIST_BINS).fill(0);
      for (let d of deltas) {
        const i = Math.min(
          HIST_BINS - 1,
          Math.floor(d / HIST_MAX_MS * HIST_BINS)
        );
        bins[i]++;
      }

      const max = Math.max(...bins, 1);
      const w = c.width / HIST_BINS;
    //  const tick = 1 / 3 * 60000 / bpm / HIST_MAX_MS;
    const tick = bpm ? (1 / 3 * 60000 / bpm / HIST_MAX_MS) : 0;


      for (let i = 0; i < HIST_BINS; i++) {
        const h = bins[i] / max * c.height;
        const thresh = tick / 2 * HIST_BINS;

        ctx.fillStyle = '#66ccff';
        if (i > thresh)
          ctx.fillStyle = '#cc66ff';
        ctx.fillRect(
          i * w,
          c.height - h,
          w - 1,
          h
        );
      }

      if (bpm > 0) {
        ctx.lineWidth = 3;
        ctx.strokeStyle = "yellow";
        ctx.beginPath();
        ctx.moveTo(tick * c.width, 0.0);
        ctx.lineTo(tick * c.width, c.height);
        ctx.stroke();
      }

      count_left = 0;
      count_right = 0;
      bary_left = 0;
      bary_right = 0;
      vari_left = 0;
      vari_right = 0;
      for (let i = 0; i < HIST_BINS; i++) {
        const p = (i + .5) / HIST_BINS;
        const thresh = tick / 2 * HIST_BINS;
        const h = bins[i] * 1;
        const h_ = bins[i] * p;
        const h__ = bins[i] * p * p;
        if (i > thresh) {
          count_right += h;
          bary_right += h_;
          vari_right += h__;
        } else {
          count_left += h;
          bary_left += h_;
          vari_left += h__
        }
      }
      if (count_left > 0)
        bary_left /= count_left;
        vari_left /= count_left;
        vari_left -= bary_left * bary_left;
        vari_left = Math.sqrt(vari_left);
      if (count_right > 0) {
        bary_right /= count_right;
        vari_right /= count_right;
        vari_right -= bary_right * bary_right;
        vari_right = Math.sqrt(vari_right);
      }

      std_left_ms = 0;
      std_right_ms = 0;
        if (count_left > 0) {
        std_left_ms = vari_left * HIST_MAX_MS;
      }
        if (count_right > 0) {
        std_right_ms = vari_right * HIST_MAX_MS;
      }

      { // std dev blue
        const stdEl = document.getElementById('std_left');
        stdEl.textContent = count_left ? std_left_ms.toFixed(0) : '—';
      }

      { // std dev rose
        const stdEl = document.getElementById('std_right');
        stdEl.textContent = count_right ? std_right_ms.toFixed(0) : '—';
      }


      { // counts
        const l = document.getElementById('count_left');
        l.innerText = count_left;
        const l_ = document.getElementById('count_right');
        l_.innerText = count_right;
      }

      { // baycenters
        const l = document.getElementById('bary_left');
        l.innerText = (bary_left * HIST_MAX_MS).toFixed(0);
        const l_ = document.getElementById('bary_right');
        l_.innerText = (bary_right * HIST_MAX_MS).toFixed(0);
      }

      { // tempos
        //const tempo_right = 0.92 * 20000 / (bary_right * HIST_MAX_MS) + 4; //14 / 15
        const tempo_right = 60000 / (3 * (bary_left * HIST_MAX_MS / 2 + bary_right * HIST_MAX_MS));
        const l_ = document.getElementById('tempo_right');
        l_.textContent =
          bary_right ? tempo_right.toFixed(0) : '— ';
      }

      { // mean blue
        ctx.lineWidth = 8;
        ctx.strokeStyle = '#0ff';
        ctx.beginPath();
        ctx.moveTo(bary_left * c.width, 0.0);
        ctx.lineTo(bary_left * c.width, c.height);
        ctx.stroke();
      }

      { // mean rose
        ctx.strokeStyle = '#f0f';
        ctx.beginPath();
        ctx.moveTo(bary_right * c.width, 0.0);
        ctx.lineTo(bary_right * c.width, c.height);
        ctx.stroke();
      }

      { // bottom axis
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#fff';
        ctx.beginPath();
        ctx.moveTo(0, c.height);
        ctx.lineTo(c.width, c.height);
        ctx.stroke();
        for (let i = 0; i < HIST_MAX_MS; i += 50) {
          const p = i / HIST_MAX_MS;
          ctx.beginPath();
          ctx.moveTo(p * c.width, 0.90 * c.height);
          ctx.lineTo(p * c.width, 0.95 * c.height);
          ctx.stroke();
        }
        for (let i = 0; i < HIST_MAX_MS; i += 10) {
          const p = i / HIST_MAX_MS;
          ctx.beginPath();
          ctx.moveTo(p * c.width, 0.95 * c.height);
          ctx.lineTo(p * c.width, c.height);
          ctx.stroke();
        }
      }
    }

    /* render target */
    function renderTarget() {
      const c = document.getElementById('target');
      const ctx = c.getContext('2d');
      ctx.clearRect(0, 0, c.width, c.height);

      // Nothing to draw yet
      if (!count_left && !count_right) return;

      // Use a single scale so ellipse isn't distorted
      const scale = c.height / HIST_MAX_MS; // 1 ms = pixels vertically
      const factor = 10; // adjust for visual size

      // Center x on bary_right/2
      const cx = (bary_right * HIST_MAX_MS / 2) * (c.width / HIST_MAX_MS);
      const cy = c.height / 2;

      // σ to pixels
      const ry = std_left_ms * scale * factor;  // horizontal = rose σ
      const rx = std_right_ms * scale * factor; // vertical = blue σ

      // Draw ellipse
      ctx.strokeStyle = '#ff0000';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(cx, cy, rx, ry, 0, 0, 2 * Math.PI);
      ctx.stroke();

      // Draw crosshairs
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 0.1;
      // horizontal
      ctx.beginPath();
      ctx.moveTo(cx - rx - 10, cy);
      ctx.lineTo(cx + rx + 10, cy);
      ctx.stroke();
      // vertical
      ctx.beginPath();
      ctx.moveTo(cx, cy - ry - 10);
      ctx.lineTo(cx, cy + ry + 10);
      ctx.stroke();
      // area txt
      const precision = std_left_ms + std_right_ms;
      ctx.fillStyle = '#fff';
      ctx.font = '30px monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(precision.toFixed(0), cx, cy);
    }




    /* ---------------- RENDER ---------------- */
    function render() {
      const grid = document.getElementById('grid');
      grid.innerHTML = '';

      for (let o of OCTAVES) {
        let col = '';
        for (let i = 11; i >= 0; i--) {
          if (o === 6 && i !== 0) continue;
          if (!showAccidentals && isAccidental(i)) continue;

          const midi = (o + 1) * 12 + i;
          let dt = '';

          if (intervals[midi] !== null && intervals[midi] <= MAX_INTERVAL_MS) {
            dt = ` ${String(Math.floor(intervals[midi])).padStart(5, ' ')}ms`;
          }

          col += `${NOTES[i]}${o} : ${counters[midi]}${dt}\n`;
        }

        const div = document.createElement('div');
        div.className = 'octave';
        div.textContent = col;
        grid.appendChild(div);
      }

      document.getElementById('total').textContent = total;

      const now = performance.now();
      noteTimes = noteTimes.filter(t => now - t < WINDOW_SEC * 1000);
      document.getElementById('nps').textContent =
        (noteTimes.length / WINDOW_SEC).toFixed(0);

      const avgVel = velocities.length
        ? Math.round(velocities.reduce((a, b) => a + b, 0) / velocities.length)
        : 0;
      document.getElementById('avgVel').textContent = avgVel;

      document.getElementById('bpm').textContent =
        bpm ? bpm.toFixed(0) : '—';

      renderLeaderboard();
      renderHistogram();
      renderTarget();
      
    }

    /* ---------------- MIDI ---------------- */
    navigator.requestMIDIAccess().then(midi => {
      const select = document.getElementById('midiSelect');

      for (let input of midi.inputs.values()) {
        const opt = document.createElement('option');
        opt.value = input.id;
        opt.text = input.name;
        select.appendChild(opt);
      }

      select.onchange = () => {
        if (currentInput) currentInput.onmidimessage = null;
        currentInput = midi.inputs.get(select.value);

        currentInput.onmidimessage = msg => {
          const [status, note, velocity] = msg.data;
          if ((status & 0xf0) === 0x90 && velocity > 0 && counters[note] !== undefined) {
            const now = performance.now();

            counters[note]++;
            total++;
            noteTimes.push(now);

            velocities.push(velocity);
            if (velocities.length > VEL_WINDOW) velocities.shift();

            if (lastTimes[note] !== null) {
              intervals[note] = now - lastTimes[note];
            }
            lastTimes[note] = now;

            // ---- TEMPO ----
            barTimes.push(now);
            if (barTimes.length > BAR_NOTES + 1) barTimes.shift();

            if (barTimes.length === BAR_NOTES + 1) {
              const dt = barTimes[BAR_NOTES] - barTimes[0];
              bpm = (4 * 60000) / dt;
            }

            // ---- HISTOGRAM DELTAS ----
            if (barTimes.length >= 2) {
              const d = barTimes[barTimes.length - 1] -
                barTimes[barTimes.length - 2];
              const v = velocity;
              if (d <= HIST_MAX_MS) {
                deltas.push(d);
                if (deltas.length > NOTE_BUFFER) deltas.shift();
                // lastVelocities.push(v);
                // if (lastVelocities.length > 72) lastVelocities.shift();
              }
            }

            render();
          }
        };
      };
    });

    /* ---------------- UI ---------------- */
    document.getElementById('accToggle').onchange = e => {
      showAccidentals = e.target.checked;
      render();
    };

    document.addEventListener('keydown', e => {
      if (e.key.toLowerCase() === 'r') {
        for (let k in counters) counters[k] = 0;
        for (let k in lastTimes) lastTimes[k] = null;
        for (let k in intervals) intervals[k] = null;
        total = 0;
        noteTimes = [];
        velocities = [];
        barTimes = [];
        deltas = [];
        // lastVelocities = [];
        bpm = 0;
        render();
      }
    });

    render();
  </script>
</body>

</html>